var LT = LT || new function(){};


/*
 Dependancy Injection Service for classes
 */
LT.DI = {}
/*
Usage:
 LT.DI.Injector.register("Beer", {
    resolve: Beer,
    requires:["Hops","Malt"],
    scope: "Instance",
    defaults:{"default", "values", "constructor", "would normally require", "but addded", "after requires"]
 });
 */
//TODO: Refactor to use _resolvee and _lookup in the main resolve function completely. It doesn't do it right yet.
LT.DI.Injector = LT.Helpers.Classes.create({
    dependencies: [],
    register: function(key, value) {
        this.dependencies[key] = value;
    },
    _lookup:function(dependancy){
        for(var i in this.dependencies){
            if (i === arguments[0]){
                return this.dependencies[i];
            }
        }
    },
    _resolve:function(d){
        var params =[d.resolve];
        var resolved = [];
        if (d.requires && d.requires.length > 0){


            for( var reqItem in d.requires)
            {
                var inst = this._lookup(d.requires[reqItem]);
                if (!d) throw "Could not find dependency " + d.requires[reqItem];

                resolved.push(this._resolve(inst));
            }
        }
        if (resolved.length > 0){
            params = params.concat(resolved);
        }

        return new (Function.prototype.bind.apply(d.resolve,params.concat(d.defaults)));
    },
    resolve: function() {
        if(arguments.length > 0 &&  Object.prototype.toString.call( arguments[0]) === '[object Array]' ){
            return this._resolve({
                requires: arguments[0],
                resolve: arguments[1],
                scope: "Instance"
            });
        }
        else if(typeof arguments[0] === 'string') {
            for(var i in this.dependencies){
                if (i === arguments[0]){
                    var result = null;

                    if(!this.dependencies[i].scope
                        || (this.dependencies[i].scope === "Instance"
                        || (this.dependencies[i].scope !== "Instance" && !this.dependencies[i].object)))
                    {
                        var constructorParams = [this.dependencies[i].resolve];

                        if (this.dependencies[i].requires && this.dependencies[i].requires.length > 0)
                        {
                            for( var reqItem in this.dependencies[i].requires)
                            {
                                var d = this._lookup(this.dependencies[i].requires[reqItem]);
                                if (!d) throw "Could not find dependency " + this.dependencies[i].requires[reqItem];

                                constructorParams.push(this._resolve(d));
                            }
                        }

                        if (arguments.length > 1){
                            constructorParams = constructorParams.concat(Array.prototype.slice.call(arguments, 1));
                        }

                        result = new (Function.prototype.bind.apply(this.dependencies[i].resolve, constructorParams ));

                        this.dependencies[i].object = result;
                    }
                    else if (this.dependencies[i].scope === "Singleton" && this.dependencies[i].object){
                        result = this.dependencies[i].object;
                    }

                    return result;
                }
            }
        }
    }
});

// Goals:
/*
var Beer = function(x,y,z){}
LT.DI.Injector.register("Beer", ["Hops", "Ginger", Beer]).AsSingleton();
LT.DI.Injector.register(["Hops", Ginger"]).As(Beer)
LT.DI.Injector.register("Beer", {
    require:["Hops","Ginger"],
    resolve: Beer,
    scope: "Instance"
});
LT.DI.Injector.resolve("Beer");
var carlton = LT.DI.Injector.resolve("Beer", function(b){
});
carlton("Carlton");
 */

/*
Generic Class helpers for ECMAScript < 6;
 */
LT.Helpers = {};
LT.Helpers.Classes = {};
LT.Helpers.Classes.create = function (self,constructor){
    constructor = constructor || function(){}
    self = self || {};

    var selfObject= function(){}
    selfObject.prototype = Object.create({});

    for(var k in self) selfObject[k]=self[k];

    var child = function(args){
        constructor.call(this, ...arguments);
    }
    child.prototype = Object.create(selfObject);
    child.prototype.constructor = constructor;

    return child;
}
LT.Helpers.Classes.inherit = function (parent, self,constructor, ignoreConstructor){
    constructor = constructor || function(){}
    parent = parent || function(){};
    self = self || {};
    ignoreConstructor = ignoreConstructor || false;

    var selfObject= function(){}
    selfObject.prototype = Object.create(parent.prototype);
    if (parent.length > constructor.length && !ignoreConstructor){
        document.getElementById("demo").innerHTML ="fail";
        return;
    }

    for(var k in self) selfObject[k]=self[k];

    var child = function(arg){
        parent.call(this,...arguments);
        constructor.call(this,...arguments);
    }
    child.prototype = Object.create(selfObject);
    child.prototype.constructor = constructor;

    return child;
}
/* END */

LT.Defns = {};

//======================================================================================================================
// Scene
//======================================================================================================================
LT.Defns.Scene = {};

LT.Defns.Scene.ComposedScene = LT.Helpers.Classes.create({
    pointcloud:null,
    scene:null,
    sceneBG:null,
    scenePointCloud: null,
    camera:null,
    cameraBG:null,
    renderer: null,
    skybox: null,
    lights:[]
},
function(width, height){
    var aspect = width / height;
    var near = 0.1;
    var far = 1000*1000;

    this.scene = new THREE.Scene();
    this.scenePointCloud = new THREE.Scene();
    this.sceneBG = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    this.cameraBG = new THREE.Camera();
    this.camera.rotation.order = 'ZYX';
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(width, height);
    this.renderer.autoClear = false;
    this.skybox = Potree.utils.loadSkybox("../resources/textures/skybox/");

    var texture = Potree.utils.createBackgroundTexture(512, 512);

    texture.minFilter = texture.magFilter = THREE.NearestFilter;
    texture.minFilter = texture.magFilter = THREE.LinearFilter;

    var bg = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(2, 2, 0),
        new THREE.MeshBasicMaterial({
            map: texture
        })
    );
    //bg.position.z = -1;
    bg.material.depthTest = false;
    bg.material.depthWrite = false;
    this.sceneBG.add(bg);
});

LT.Defns.Scene.SceneManager = LT.Helpers.Classes.create(
    {
        renderLocation: null,
        //renderer: null,
        processor: null,
        //camera: null,
        toolManager: null,
        scenePointCloud: null,
        composedScene:null,
        processors:[],
        intensityMax:null,
        freeze:false,
        clipBoxes:[],
        render: function(){
            // Resize as needed.
            var width = this.renderLocation.clientWidth;
            var height = this.renderLocation.clientHeight;
            var aspect = width / height;

            this.composedScene.renderer.clear();

            this.composedScene.camera.aspect = aspect;
            this.composedScene.camera.updateProjectionMatrix();

            this.composedScene.renderer.setSize(width, height);
            this.processor.resize(width,height);

            if(showSkybox && this.composedScene.skybox){
                this.composedScene.skybox.camera.rotation.copy(this.composedScene.camera.rotation);
                this.composedScene.renderer.render(this.composedScene.skybox.scene, this.composedScene.skybox.camera);
            }else{
                this.composedScene.renderer.render(this.composedScene.sceneBG, this.composedScene.cameraBG);
            }

            this.processor.render(this.composedScene, this.renderer);
            this.composedScene.renderer.render(this.composedScene.scene, this.composedScene.camera);
            this.composedScene.renderer.render(this.composedScene.scenePointCloud, this.composedScene.camera);
            this.toolManager.postRender();
            this.composedScene.renderer.clearDepth();
            this.toolManager.postRenderNoDepth();
        },
        addToScene: function(object){
            this.composedScene.scene.add(object);
        },
        addLight: function(light){
            this.composedScene.lights.push(light);
            this.composedScene.scenePointCloud.add( light );
        },
        addProcessor:function(name, processor){
            this.processors[name] = processor;
        },
        getCurrentScene:function(){ return this.composedScene; },
        update: function(){
            this.clipBoxes = [];
            if(this.composedScene.pointcloud){
                if(!this.intensityMax){
                    var root = this.composedScene.pointcloud.pcoGeometry.root;
                    if(root != null && root.loaded){
                        var attributes = this.composedScene.pointcloud.pcoGeometry.root.geometry.attributes;
                        if(attributes.intensity){
                            var array = attributes.intensity.array;
                            var max = 0;
                            for(var i = 0; i < array.length; i++){
                                max = Math.max(array[i]);
                            }

                            if(max <= 1){
                                this.intensityMax = 1;
                            }else if(max <= 256){
                                this.intensityMax = 255;
                            }else{
                                this.intensityMax = max;
                            }
                        }
                    }
                }

                if(heightMin === null){
                    var bbWorld = Potree.utils.computeTransformedBoundingBox(this.composedScene.pointcloud.boundingBox, this.composedScene.pointcloud.matrixWorld);
                    heightMin = bbWorld.min.y;
                    heightMax = bbWorld.max.y;
                }

                this.composedScene.pointcloud.material.clipMode = clipMode;
                this.composedScene.pointcloud.material.heightMin = heightMin;
                this.composedScene.pointcloud.material.heightMax = heightMax;
                this.composedScene.pointcloud.material.intensityMin = 0;
                this.composedScene.pointcloud.material.intensityMax = intensityMax;
                this.composedScene.pointcloud.showBoundingBox = showBoundingBox;
                this.composedScene.pointcloud.generateDEM = useDEMCollisions;
                this.composedScene.pointcloud.minimumNodePixelSize = minNodeSize;

                if(!this.freeze){
                    this.composedScene.pointcloud.update(camera, renderer);
                }


            }
        },
        postUpdate:function(){
            if(this.composedScene.pointcloud){
                this.composedScene.pointcloud.material.setClipBoxes(this.clipBoxes);
            }
        }
    },
    function( renderLocation, composedScene, processor, toolManager){
        if (!renderLocation) throw "Not setup correctly, render location required";
        if (!processor)throw "Not setup correctly, processor required";

        this.renderLocation = renderLocation;
        this.processor = processor;
        this.composedScene = new LT.Defns.Scene.ComposedScene();
        this.toolManager = toolManager;
    }
);

//----------------------------------------------------------------------------------------------------------------------
// Processors
//----------------------------------------------------------------------------------------------------------------------
LT.Defns.Scene.SceneProcessor = LT.Helpers.Classes.create({
    resize: function(width, height){},
    render: function(composedScene, renderer){}
});

LT.Defns.Scene.PotreeSceneProcessor = LT.Helpers.Classes.inherit(LT.Defns.Scene.SceneProcessor, {
    render : function(composedScene, renderer){
        // render skybox
        if(composedScene.pointcloud){
            if (composedScene.pointcloud.originalMaterial){
                composedScene.pointcloud.material = pointcloud.originalMaterial;
            }

            var bbWorld = Potree.utils.computeTransformedBoundingBox(composedScene.pointcloud.boundingBox, composedScene.pointcloud.matrixWorld);

            composedScene.pointcloud.visiblePointsTarget = pointCountTarget * 1000 * 1000;
            composedScene.pointcloud.material.size = pointSize;
            composedScene.pointcloud.material.opacity = opacity;
            composedScene.pointcloud.material.pointColorType = pointColorType;
            composedScene.pointcloud.material.pointSizeType = pointSizeType;
            composedScene.pointcloud.material.pointShape = (quality === "Circles") ? Potree.PointShape.CIRCLE : Potree.PointShape.SQUARE;
            composedScene.pointcloud.material.interpolate = (quality === "Interpolation");
            composedScene.pointcloud.material.weighted = false;
        }
    }
});

LT.Defns.Scene.EDLProcessor = LT.Helpers.Classes.inherit(LT.Defns.Scene.SceneProcessor,
    {
        edlMaterial:null,
        attributeMaterial: null,
        rtColor : null,
    //var gl = renderer.context;
        resize: function(width, height){
            var needsResize = (rtColor.width != width || rtColor.height != height);

            // disposal will be unnecessary once this fix made it into three.js master:
            // https://github.com/mrdoob/three.js/pull/6355
            if(needsResize){
                rtColor.dispose();
            }

            rtColor.setSize(width, height);
        },

        render: function(composedScene, renderer){

            if(pointcloud){
                var octreeSize = composedScene.pointcloud.pcoGeometry.boundingBox.size().x;

                composedScene.pointcloud.visiblePointsTarget = pointCountTarget * 1000 * 1000;
                var originalMaterial = composedScene.pointcloud.material;

                {// COLOR & DEPTH PASS
                    attributeMaterial.size = pointSize;
                    attributeMaterial.pointSizeType = pointSizeType;
                    attributeMaterial.screenWidth = width;
                    attributeMaterial.screenHeight = height;
                    attributeMaterial.pointColorType = pointColorType;
                    attributeMaterial.uniforms.visibleNodes.value = composedScene.pointcloud.material.visibleNodesTexture;
                    attributeMaterial.uniforms.octreeSize.value = octreeSize;
                    attributeMaterial.fov = composedScene.camera.fov * (Math.PI / 180);
                    attributeMaterial.spacing = composedScene.pointcloud.pcoGeometry.spacing;
                    attributeMaterial.near = composedScene.camera.near;
                    attributeMaterial.far = composedScene.camera.far;
                    attributeMaterial.heightMin = heightMin;
                    attributeMaterial.heightMax = heightMax;
                    attributeMaterial.intensityMin = composedScene.pointcloud.material.intensityMin;
                    attributeMaterial.intensityMax = composedScene.pointcloud.material.intensityMax;
                    attributeMaterial.setClipBoxes(composedScene.pointcloud.material.clipBoxes);
                    attributeMaterial.clipMode = composedScene.pointcloud.material.clipMode;
                    attributeMaterial.bbSize = composedScene.pointcloud.material.bbSize;
                    attributeMaterial.treeType = composedScene.pointcloud.material.treeType;

                    composedScene.scenePointCloud.overrideMaterial = this.attributeMaterial;
                    composedScene.renderer.clearTarget( this.rtColor, true, true, true );
                    composedScene.renderer.render(composedScene.scenePointCloud, composedScene.camera,this.rtColor);
                    composedScene.scenePointCloud.overrideMaterial = null;
                }

                { // EDL OCCLUSION PASS
                    this.edlMaterial.uniforms.screenWidth.value = width;
                    this.edlMaterial.uniforms.screenHeight.value = height;
                    this.edlMaterial.uniforms.near.value = camera.near;
                    this.edlMaterial.uniforms.far.value = camera.far;
                    this.edlMaterial.uniforms.colorMap.value = rtColor;
                    this.edlMaterial.uniforms.expScale.value = camera.far;

                    //edlMaterial.uniforms.depthMap.value = depthTexture;

                    Potree.utils.screenPass.render(composedScene.renderer, this.edlMaterial);
                }

                renderer.render(scene, camera);
            }
        }
    },
    function(){
        if(this.edlMaterial != null){
            return;
        }

        //var depthTextureExt = gl.getExtension("WEBGL_depth_texture");

        this.edlMaterial = new Potree.EyeDomeLightingMaterial();
        this.attributeMaterial = new Potree.PointCloudMaterial();

        this.attributeMaterial.pointShape = Potree.PointShape.CIRCLE;
        this.attributeMaterial.interpolate = false;
        this.attributeMaterial.weighted = false;
        this.attributeMaterial.minSize = 2;
        this.attributeMaterial.useLogarithmicDepthBuffer = false;
        this.attributeMaterial.useEDL = true;

        this.rtColor = new THREE.WebGLRenderTarget( 1024, 1024, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType,
            //type: THREE.UnsignedByteType,
            //depthBuffer: false,
            //stencilBuffer: false
        } );


    }
);

// render with splats
LT.Defns.Scene.HighQualityProcessor = LT.Helpers.Classes.inherit(LT.Defns.Scene.SceneProcessor,{
    depthMaterial : null,
    attributeMaterial :null,
    normalizationMaterial : null,
    rtDepth:null,
    rtNormalize: null,
    resize: function(width, height){
        if(rtDepth.width == width && rtDepth.height == height){
            return;
        }

        rtDepth.dispose();
        rtNormalize.dispose();

        rtDepth.setSize(width, height);
        rtNormalize.setSize(width, height);
    },
    render: function(composedScene, renderer){
        if(composedScene.pointcloud){

            this.depthMaterial.uniforms.octreeSize.value = composedScene.pointcloud.pcoGeometry.boundingBox.size().x;
            this.attributeMaterial.uniforms.octreeSize.value = composedScene.pointcloud.pcoGeometry.boundingBox.size().x;

            composedScene.pointcloud.visiblePointsTarget = pointCountTarget * 1000 * 1000;
            var originalMaterial = composedScene.pointcloud.material;

            {// DEPTH PASS
                this.depthMaterial.size = pointSize;
                this.depthMaterial.pointSizeType = pointSizeType;
                this.depthMaterial.screenWidth = width;
                this.depthMaterial.screenHeight = height;
                this.depthMaterial.uniforms.visibleNodes.value = composedScene.pointcloud.material.visibleNodesTexture;
                this.depthMaterial.uniforms.octreeSize.value = composedScene.pointcloud.pcoGeometry.boundingBox.size().x;
                this.depthMaterial.fov = composedScene.camera.fov * (Math.PI / 180);
                this.depthMaterial.spacing = composedScene.pointcloud.pcoGeometry.spacing;
                this.depthMaterial.near = composedScene.camera.near;
                this.depthMaterial.far = composedScene.camera.far;
                this.depthMaterial.heightMin = heightMin;
                this.depthMaterial.heightMax = heightMax;
                this.depthMaterial.uniforms.visibleNodes.value = composedScene.pointcloud.material.visibleNodesTexture;
                this.depthMaterial.uniforms.octreeSize.value = composedScene.pointcloud.pcoGeometry.boundingBox.size().x;
                this.depthMaterial.bbSize = composedScene.pointcloud.material.bbSize;
                this.depthMaterial.treeType = composedScene.pointcloud.material.treeType;

                composedScene.scenePointCloud.overrideMaterial = depthMaterial;
                composedScene.renderer.clearTarget( rtDepth, true, true, true );
                composedScene.renderer.render(scenePointCloud, camera, rtDepth);
                composedScene.scenePointCloud.overrideMaterial = null;
            }

            {// ATTRIBUTE PASS
                this.attributeMaterial.size = pointSize;
                this.attributeMaterial.pointSizeType = pointSizeType;
                this.attributeMaterial.screenWidth = width;
                this.attributeMaterial.screenHeight = height;
                this.attributeMaterial.pointColorType = pointColorType;
                this.attributeMaterial.depthMap = rtDepth;
                this.attributeMaterial.uniforms.visibleNodes.value = composedScene.pointcloud.material.visibleNodesTexture;
                this.attributeMaterial.uniforms.octreeSize.value = composedScene.pointcloud.pcoGeometry.boundingBox.size().x;
                this.attributeMaterial.fov = composedScene.camera.fov * (Math.PI / 180);
                this.attributeMaterial.spacing = composedScene.pointcloud.pcoGeometry.spacing;
                this.attributeMaterial.near = composedScene.camera.near;
                this.attributeMaterial.far = composedScene.camera.far;
                this.attributeMaterial.heightMin = heightMin;
                this.attributeMaterial.heightMax = heightMax;
                this.attributeMaterial.intensityMin = composedScene.pointcloud.material.intensityMin;
                this.attributeMaterial.intensityMax = composedScene.pointcloud.material.intensityMax;
                this.attributeMaterial.setClipBoxes(composedScene.pointcloud.material.clipBoxes);
                this.attributeMaterial.clipMode = composedScene.pointcloud.material.clipMode;
                this.attributeMaterial.bbSize = composedScene.pointcloud.material.bbSize;
                this.attributeMaterial.treeType = composedScene.pointcloud.material.treeType;

                composedScene.scenePointCloud.overrideMaterial = this.attributeMaterial;
                composedScene.renderer.clearTarget( this.rtNormalize, true, true, true );
                composedScene.renderer.render(composedScene.scenePointCloud, composedScene.camera, this.rtNormalize);
                composedScene.scenePointCloud.overrideMaterial = null;
            }

            {// NORMALIZATION PASS
                this.normalizationMaterial.uniforms.depthMap.value = this.rtDepth;
                this.normalizationMaterial.uniforms.texture.value = this.rtNormalize;
                Potree.utils.screenPass.render(composedScene.renderer, this.normalizationMaterial);
            }

            composedScene.pointcloud.material = originalMaterial;

        }
    }
},
function(){
    if(this.depthMaterial != null){
        return;
    }

    this.depthMaterial = new Potree.PointCloudMaterial();
    this.attributeMaterial = new Potree.PointCloudMaterial();

    this.depthMaterial.pointColorType = Potree.PointColorType.DEPTH;
    this.depthMaterial.pointShape = Potree.PointShape.CIRCLE;
    this.depthMaterial.interpolate = false;
    this.depthMaterial.weighted = false;
    this.depthMaterial.minSize = 2;

    this.attributeMaterial.pointShape = Potree.PointShape.CIRCLE;
    this.attributeMaterial.interpolate = false;
    this.attributeMaterial.weighted = true;
    this.attributeMaterial.minSize = 2;

    this.rtDepth = new THREE.WebGLRenderTarget( 1024, 1024, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType
    } );

    this.rtNormalize = new THREE.WebGLRenderTarget( 1024, 1024, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType
    } );

    var uniformsNormalize = {
        depthMap: { type: "t", value: rtDepth },
        texture: { type: "t", value: rtNormalize }
    };

    this.normalizationMaterial = new THREE.ShaderMaterial({
        uniforms: uniformsNormalize,
        vertexShader: Potree.Shaders["normalize.vs"],
        fragmentShader: Potree.Shaders["normalize.fs"]
    });
})

//======================================================================================================================
// Undo
//======================================================================================================================
LT.Defns.Undo = {};
LT.Defns.Undo.Action = LT.Helpers.Classes.create({
    dataset:null,
    do:function(dataset){},
    undo: function(dataset){}
});

LT.Defns.Undo.UndoManager = LT.Helpers.Classes.create({
    actions:[],
    undoLimit: 100,
    currenPosition: -1,
    addAction:function(action){
        this.actions.push(action);
    },
    undo: function(){},
    redo: function(){}
});

//======================================================================================================================
// Tools
//======================================================================================================================
LT.Defns.Tools = {};

LT.Defns.Tools.BaseTool = LT.Helpers.Classes.create({
    diContainer: null,
    sceneManaged: false,
    update:function(){},
    render:function(){},
    clear:function(){},
    start:function(){},
    cancel:function(){},
    onClick:function(event){},
    onMouseMove:function(event){},
    onMouseDown:function(event){},
    onMouseUp:function(event){},
    onRightClick:function(event){},
    onDoubleClick:function(event){},
},function(diContainer){
    this.diContainer = diContainer;
});

LT.Defns.Tools.ProfileTool = LT.Helpers.Classes.inherit(LT.Defns.Tools.BaseTool,
    {
        potreeTool:null,
        sceneManager:null,
        update: function(){
            var clipBoxes = [];
            for(var i = 0; i < this.potreeTool.profiles.length; i++){
                var profile = this.potreeTool.profiles[i];

                for(var j = 0; j < profile.boxes.length; j++){
                    var box = profile.boxes[j];
                    box.updateMatrixWorld();
                    var boxInverse = new THREE.Matrix4().getInverse(box.matrixWorld);
                    clipBoxes.push(boxInverse);
                }
            }

            var composedScene = sceneManager.getCurrentScene();
            sceneManager.addClipBoxes(clipBoxes);

        }
    },
    function(sceneManager){
        this.sceneManager = sceneManager;
        //var sceneManager = diContainer.resolve("SceneManager");
        var composedScene = sceneManager.getCurrentScene();
        this.potreeTool = new Potree.ProfileTool(composedScene.scenePointCloud, composedScene.camera, composedScene.renderer);
    }
);

LT.Defns.Tools.ToolManager = LT.Helpers.Classes.create({
    postRenderTools:[],
    postRenderNoDepthTools:[],

    addPostRender: function(name, tool){
        this.postRenderTools[name] = tool;
    },
    addPostRenderNoDepth: function(name, tool){
        this.postRenderNoDepthTools[name] = tool;
    },
    get: function(name){
        return this.postRenderTools[name] || this.postRenderNoDepthTools[name];
    },
    postRender: function(){
        for(var t in this.postRenderTools)
        {
            t.render();
        }
    },
    postRenderNoDepth: function(){
        for(var t in this.postRenderNoDepthTools)
        {
            t.render();
        }
    },
    update:function(){
        for (var tool in this.postRenderTools){
            tool.update();
        }
        for (var tool in this.postRenderNoDepthTools){
            tool.update();
        }


        // I have to move these things.
        //  I have to look at making the scene manager and its components transparent to tools.
        // this way any future effects can be mitigated.
        // also I may need to create my own tools wrapper.
        // this will allow me to extend with NON-potree tools.
        // big bada boom.
        var clipBoxes = [];

        for(var i = 0; i < profileTool.profiles.length; i++){
            var profile = profileTool.profiles[i];

            for(var j = 0; j < profile.boxes.length; j++){
                var box = profile.boxes[j];
                box.updateMatrixWorld();
                var boxInverse = new THREE.Matrix4().getInverse(box.matrixWorld);
                clipBoxes.push(boxInverse);
            }
        }

        for(var i = 0; i < volumeTool.volumes.length; i++){
            var volume = volumeTool.volumes[i];

            if(volume.clip){
                volume.updateMatrixWorld();
                var boxInverse = new THREE.Matrix4().getInverse(volume.matrixWorld);

                clipBoxes.push(boxInverse);
            }
        }

        if(pointcloud){
            pointcloud.material.setClipBoxes(clipBoxes);
        }
    }
},function(diContainer){});

LT.Defns.Tools.LT_MainViewerToolManager = LT.Helpers.Classes.inherit(LT.Defns.Tools.ToolManager,{},
    function(diContainer){
        var sceneManager = diContainer.resolve("SceneManager");
        var composedScene = sceneManager.getCurrentScene();

        this.addPostRenderTool("Profile Tool",diContainer.resolve(["SceneManager"],LT.Defns.Tools.ProfileTool));//(diContainer));
        this.addPostRenderTool("Volume Tool", new Potree.VolumeTool(composedScene.scenePointCloud, composedScene.camera, composedScene.renderer));
        this.addPostRenderNoDepthTool("Measuring Tool", new Potree.MeasuringTool(composedScene.scenePointCloud, composedScene.camera, composedScene.renderer));
        this.addPostRenderNoDepthTool("Transformation Tool", new Potree.TransformationTool(composedScene.scenePointCloud, composedScene.camera, composedScene.renderer));
    }
);

//======================================================================================================================
// Controls
//======================================================================================================================
LT.Defns.Controls = {};

LT.Defns.Controls.ControlsManager = LT.Helpers.Classes.create(
    {
        schemes:[],
        activeScheme:null,
        addScheme: function(name, controlScheme){
            if (!(controlScheme instanceof LT.Defns.Controls.ControlScheme)) throw "Invalid control scheme instance";

            this.schemes[name] = controlScheme;
        },
        setActive:function(name){
            if (name == null)
            {
                this.activeScheme = null;
                return;
            }
            if (this.activeScheme){
                this.activeScheme.disable();
            }
            this.activeScheme = this.schemes[name];
            this.activeScheme.enable();
        },
        onKeyDown:function(event){},
        update: function(delta){
            if (this.activeScheme){
                this.activeScheme.update(delta);
            }
        }
    },
    function(){
        window.addEventListener( 'keydown', this.onKeyDown, false );
    }
);

LT.Defns.Controls.ControlsManager.LT_MainViewerControlsManager = LT.Helpers.Classes.inherit(LT.Defns.Controls.ControlsManager,
    {
        onKeyDown:function(event){
            function onKeyDown(event){
                //console.log(event.keyCode);

                if(event.keyCode === 69){
                    // e pressed

                    transformationTool.translate();
                }else if(event.keyCode === 82){
                    // r pressed

                    transformationTool.scale();
                }else if(event.keyCode === 84){
                    // r pressed

                    transformationTool.rotate();
                }
            };
        }
    },
function(camera, renderer, pointcloud, useDEMCollisions){
    this.addScheme("FPS", new LT.Defns.Controls.FPSControlScheme(camera, renderer, pointcloud, useDEMCollisions));
    this.addScheme("Earth", new LT.Defns.Controls.EarthControlScheme(camera, renderer, pointcloud, useDEMCollisions));
    this.addScheme("Orbit", new LT.Defns.Controls.OrbitControlScheme(camera,renderer,pointcloud,useDEMCollisions));

    this.setActive("Earth");
});

LT.Defns.Controls.ControlScheme = LT.Helpers.Classes.create({
    disable:function(){},
    enable:function(){},
    update: function(delta){}
});

LT.Defns.Controls.FPSControlScheme = LT.Helpers.Classes.inherit(LT.Defns.Controls.ControlScheme,{
    controls: null,
    enable: function(){ this.controls.enabled = true; },
    disable: function(){ this.controls.enabled = false; },
    update: function(delta){ controls.update(delta); }
    },
    function(camera, renderer, pointcloud, useDEMCollisions){
        this.controls = new THREE.FirstPersonControls(camera, renderer.domElement);
        this.controls.addEventListener("proposeTransform", function(event){
            if(!pointcloud || !useDEMCollisions){
                return;
            }

            var demHeight = pointcloud.getDEMHeight(event.newPosition);
            if(event.newPosition.y < demHeight){
                event.objections++;

                var counterProposal = event.newPosition.clone();
                counterProposal.y = demHeight;

                event.counterProposals.push(counterProposal);
            }
        });

        this.controls.moveSpeed = pointcloud.boundingSphere.radius / 6;
    }
);

LT.Defns.Controls.EarthControlScheme = LT.Helpers.Classes.inherit(LT.Defns.Controls.ControlScheme,{
    controls: null,
    enable: function(){ this.controls.enabled = true; },
    disable: function(){ this.controls.enabled = false; },
    update: function(delta){ controls.update(delta); }
    },
    function(camera, renderer, pointcloud, useDEMCollisions){
        // camera and controls
        camera.position.set(-304, 372, 318);
        camera.rotation.y = -Math.PI / 4;
        camera.rotation.x = -Math.PI / 6;
        //useOrbitControls();
        this.controls = new THREE.EarthControls(camera, renderer, scenePointCloud);
        this.controls.addEventListener("proposeTransform", function(event){
            if(!pointcloud || !useDEMCollisions){
                return;
            }

            var demHeight = pointcloud.getDEMHeight(event.newPosition);
            if(event.newPosition.y < demHeight){
                event.objections++;
            }
        });
    }
);

LT.Defns.Controls.OrbitControlScheme = LT.Helpers.Classes.inherit(LT.Defns.Controls.ControlScheme,
    {
        controls:null,
        enable: function(){ this.controls.enabled = true; },
        disable: function(){ this.controls.enabled = false; },
        update: function(delta){ controls.update(delta); }
    },
    function(camera, renderer, pointcloud, useDEMCollisions){
        this.controls = new Potree.OrbitControls(camera, renderer.domElement);
        this.controlsorbitControls.addEventListener("proposeTransform", function(event){
            if(!pointcloud || !useDEMCollisions){
                return;
            }

            var demHeight = pointcloud.getDEMHeight(event.newPosition);
            if(event.newPosition.y < demHeight){
                event.objections++;

                var counterProposal = event.newPosition.clone();
                counterProposal.y = demHeight;

                event.counterProposals.push(counterProposal);
            }
        });

        if(pointcloud){
            controls.target.copy(pointcloud.boundingSphere.center.clone().applyMatrix4(pointcloud.matrixWorld));
        }
    }
);
//======================================================================================================================
// Data Loaders
//======================================================================================================================
LT.Defns.Loaders = {};
LT.Defns.Loaders.PointClouds = {};
LT.Defns.Loaders.PointClouds.BaseSetup = LT.Helpers.Classes.create({
    isCompatiblePath:function(path){ return false; },
    initialise:function(path){  return null;  }
});
LT.Defns.Loaders.PointClouds.PotreeDefault = LT.Helpers.Classes.inherit(LT.Defns.Loaders.PointClouds.BaseSetup,{
    isFlipYZ: false,
    referenceFrame: null,
    isCompatiblePath:function(path){ path.indexOf("cloud.js") > 0; },
    initialise: function(path, composedScene){scenePointCloud
        this.referenceFrame = new THREE.Object3D();
        composedScene.scenePointCloud.add(referenceFrame);

        Potree.POCLoader.load(pointcloudPath, function(geometry){
            composedScene.pointcloud = new Potree.PointCloudOctree(geometry);

            pointcloud.material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
            pointcloud.material.size = pointSize;
            pointcloud.visiblePointsTarget = pointCountTarget * 1000 * 1000;

            this.referenceFrame.add(pointcloud);

            this.referenceFrame.updateMatrixWorld(true);
            var sg = pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);

            this.referenceFrame.position.copy(sg.center).multiplyScalar(-1);
            this.referenceFrame.updateMatrixWorld(true);

            if(sg.radius > 50*1000){
                camera.near = 10;
            }else if(sg.radius > 10*1000){
                camera.near = 2;
            }else if(sg.radius > 1000){
                camera.near = 1;
            }else if(sg.radius > 100){
                camera.near = 0.5;
            }else{
                camera.near = 0.1;
            }

            this.flipYZ();
            camera.zoomTo(pointcloud, 1);

            initGUI();

            earthControls.pointclouds.push(pointcloud);

            if(sceneProperties.navigation === "Earth"){
                useEarthControls();
            }else if(sceneProperties.navigation === "Orbit"){
                useOrbitControls();
            }else if(sceneProperties.navigation === "Flight"){
                useFPSControls();
            }else{
                console.warning("No navigation mode specified. Using OrbitControls");
                useOrbitControls();
            }

            if(sceneProperties.cameraPosition != null){
                var cp = new THREE.Vector3(sceneProperties.cameraPosition[0], sceneProperties.cameraPosition[1], sceneProperties.cameraPosition[2]);
                camera.position.copy(cp);
            }

            if(sceneProperties.cameraTarget != null){
                var ct = new THREE.Vector3(sceneProperties.cameraTarget[0], sceneProperties.cameraTarget[1], sceneProperties.cameraTarget[2]);
                camera.lookAt(ct);

                if(sceneProperties.navigation === "Orbit"){
                    controls.target.copy(ct);
                }
            }

        });
        return pointcloud;
    },
    flipYZ: function (){
        this.isFlipYZ = !this.isFlipYZ;

        if(this.isFlipYZ){
            this.referenceFrame.matrix.copy(new THREE.Matrix4());
            this.referenceFrame.applyMatrix(new THREE.Matrix4().set(
                1,0,0,0,
                0,0,1,0,
                0,-1,0,0,
                0,0,0,1
            ));

        }else{
            this.referenceFrame.matrix.copy(new THREE.Matrix4());
            this.referenceFrame.applyMatrix(new THREE.Matrix4().set(
                1,0,0,0,
                0,1,0,0,
                0,0,1,0,
                0,0,0,1
            ));
        }

        this.referenceFrame.updateMatrixWorld(true);
        pointcloud.updateMatrixWorld();
        var sg = pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);
        this.referenceFrame.position.copy(sg.center).multiplyScalar(-1);
        this.referenceFrame.updateMatrixWorld(true);
        this.referenceFrame.position.y -= pointcloud.getWorldPosition().y;
        this.referenceFrame.updateMatrixWorld(true);
    }
});

LT.Defns.Loaders.PointClouds.Arena4DSetup = LT.Helpers.Classes.inherit(LT.Defns.Loaders.PointClouds.BaseSetup, {
    isCompatiblePath:function (path){
        return path.indexOf(".vpc") > 0;
    },

    initialise:function(){
        var pointcloud = null;
        Potree.PointCloudArena4DGeometry.load(pointcloudPath, function(geometry){
            pointcloud = new Potree.PointCloudArena4D(geometry);
            pointcloud.visiblePointsTarget = 500*1000;

            //pointcloud.applyMatrix(new THREE.Matrix4().set(
            //	1,0,0,0,
            //	0,0,1,0,
            //	0,-1,0,0,
            //	0,0,0,1
            //));

            referenceFrame.add(pointcloud);

            flipYZ();

            referenceFrame.updateMatrixWorld(true);
            var sg = pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);

            referenceFrame.position.sub(sg.center);
            referenceFrame.position.y += sg.radius / 2;
            referenceFrame.updateMatrixWorld(true);

            camera.zoomTo(pointcloud, 1);

            initGUI();
            pointcloud.material.interpolation = false;
            pointcloud.material.pointSizeType = Potree.PointSizeType.ATTENUATED;
            earthControls.pointclouds.push(pointcloud);


            if(sceneProperties.navigation === "Earth"){
                useEarthControls();
            }else if(sceneProperties.navigation === "Orbit"){
                useOrbitControls();
            }else if(sceneProperties.navigation === "Flight"){
                useFPSControls();

            }else{
                console.warning("No navigation mode specivied. Using OrbitControls");
                useOrbitControls();
            }

            if(sceneProperties.cameraPosition != null){
                var cp = new THREE.Vector3(sceneProperties.cameraPosition[0], sceneProperties.cameraPosition[1], sceneProperties.cameraPosition[2]);
                camera.position.copy(cp);
            }

            if(sceneProperties.cameraTarget != null){
                var ct = new THREE.Vector3(sceneProperties.cameraTarget[0], sceneProperties.cameraTarget[1], sceneProperties.cameraTarget[2]);
                camera.lookAt(ct);
            }

        });
        return pointcloud;
    }
    }, function(){}
);

LT.Defns.Loaders.ObjectLoader = LT.Helpers.Classes.create(
    {
        pointCloudLoaders: [],
        loadingProgress:null,
        _loadedPointClouds:[],
        addPointCloudLoader: function (loader){
            this.pointCloudLoaders.push(loader);
        },
        loadPointCloud: function (path, composedScene){
            for(var s in this.setups){
                if (s.isCompatiblePath(path)){
                    s.initialise(path,composedScene);
                    this._loadedPointClouds.push(composedScene.pointcloud);
                    return;
                }
            }
        },
        update:function(){
            if(this._loadedPointClouds.length > 0) {
                var progress = 0;
                for(var pc in this._loadedPointClouds) {
                    progress += pc.progress;
                }
                progress = progress / this._loadedPointClouds.length;
                this.loadingProgress.setProgress(progress);

            }
        }
    },
    function(loadingProgress) {
        this.loadingProgress = loadingProgress;
    }
);

LT.Defns.Loaders.LT_MainObjectLoader = LT.Helpers.Classes.inherit(LT.Defns.Loaders.ObjectLoader, {},
    function(){
    this.addPointCloudLoader(new LT.Defns.Loaders.PotreeDefault());
    this.addPointCloudLoader(new LT.Defns.Loaders.Arena4DSetup());
});

//======================================================================================================================
// Engine
//======================================================================================================================
LT.Defns.ProgressTracker = LT.Helpers.Classes.create({
    isLoading:false,
    progress:0,
    progressElement:null,
    progressBar:null,
    setProgress:function(value){
        if (!this.progressBar || !this.progressElement){ return; }

        this.progressBar.style.width = (value * 100) + "%";

        if (value === 1) {
            this.progressElement.hide();
        } else if (value < 1) {
            this.progressElement.show();
        }
    }
},
    function(progressElement, progressBar){
        this.progressElement = progressElement;
        this.progressBar = progressBar;
    }
);


LT.Defns.DefaultSetup = LT.Helpers.Classes.create({
    renderArea: "renderArea",
    modules:[],
    sceneProperties: {
        //path:			"../resources/pointclouds/lion_takanawa/cloud.js",
        cameraPosition: null,
        cameraTarget:   null,
        sizeType: 		"Adaptive",			// options: "Fixed", "Attenuated", "Adaptive"
        quality: 		"Interpolation", 	// options: "Squares", "Circles", "Interpolation", "Splats"
        fov: 			75, 				// field of view in degree
        material: 		"RGB", 				// options: "RGB", "Height", "Intensity", "Classification"
        pointLimit: 	1,					// max number of points in millions
        navigation: 	"Orbit",			// options: "Earth", "Orbit", "Flight"
        mobileNavigation: "Orbit",
        pointSize: 		1.2,
        useEDL:			true,				// eye-dome-lighting, especially usefull for point clouds without normals
    },
    sceneObjects:{
        potreePointCloud:"../resources/pointclouds/lion_takanawa/cloud.js"
    },
    controlProperties:{
        useDEMCollisions: false,
    },
    progress:{
        element: null,
        bar: null
    },
    toolProperties:[],
    getPointSizeType : function () {
        switch(this.sceneProperties.sizeType.toLowerCase()){
            case "fixed":       return Potree.PointSizeType.FIXED;
            case "attenuated":  return Potree.PointSizeType.ATTENUATED;
            case "adaptive":    return Potree.PointSizeType.ADAPTIVE;
            default: return Potree.PointSizeType.ADAPTIVE;
        }
    },
    getQuality: function (){
        var value =this.sceneProperties.quality.toLowerCase();
        if(value == "interpolation" && !Potree.Features.SHADER_INTERPOLATION.isSupported()){
            return "Squares";
        }
        else if(value == "splats" && !Potree.Features.SHADER_SPLATS.isSupported()){
            return "Squares";
        }
        return this.sceneProperties.quality;
    },
    getMaterial: function (){
        switch(this.sceneProperties.material.toLowerCase()){
            case "rgb":         return Potree.PointColorType.RGB;
            case "color":       return Potree.PointColorType.COLOR;
            case "elevation":   return Potree.PointColorType.HEIGHT;
            case "intensity":   return Potree.PointColorType.INTENSITY;
            case "intensity gradient": return Potree.PointColorType.INTENSITY_GRADIENT;
            case "classification":  return Potree.PointColorType.CLASSIFICATION;
            case "return number":   return Potree.PointColorType.RETURN_NUMBER;
            case "source":      return  Potree.PointColorType.SOURCE;
            case "tree depth":  return Potree.PointColorType.TREE_DEPTH;
            case "point index": return Potree.PointColorType.POINT_INDEX;
            case "normal":      return Potree.PointColorType.NORMAL;
            case "phong":       return Potree.PointColorType.PHONG;
            default:            return Potree.PointColorType.RGB;
        }
    },
    getRenderArea: function(){
        return document.getElementById(this.renderArea);
    }
});
LT.Defns.Engine = {}
LT.Defns.Engine.LTEngine = LT.Helpers.Classes.create({
    clock: null,
    sceneManager:null,
    controlsManager:null,
    objectLoader:null,
    composedScene: null,
    toolsManager:null,
    settings: null,
    loadingProgress: null,
    diContainer:null,
    _initSceneManager:function(loadingProgress){ return new LT.Defns.Scene.SceneManager(loadingProgress);},
    _initControlManager:function(){ return new LT.Defns.Controls.ControlsManager();},
    _initObjectLoader:function(){ return new LT.Defns.Loaders.ObjectLoader();},
    _initComposedScene:function(width,height){ return new LT.Defns.Scene.ComposedScene(width,height);},
    _initToolsManager:function(){ return new LT.Defns.Tools.ToolManager(this.diContainer); },
    _initProgressTracker:function(element, bar){ return new LT.Defns.ProgressTracker(element, bar);},
    initialise: function(setup){
        this.diContainer = new LT.DI.Injector();



        this.loadingProgress = this._initProgressTracker(setup.progress.element, setup.progress.bar);
        this.clock = new THREE.Clock();
        this.settings = setup;
        var renderLocation = setup.getRenderArea();

        this.composedScene = this._initComposedScene(renderLocation.width, renderLocation.height);
        renderLocation.appendChild(composedScene.renderer.domElement);

        this.objectLoader = this._initObjectLoader();
        this.diContainer.register("ObjectLoader",{ object:this.objectLoader, scope:"Singleton" });

        this.sceneManager = this._initSceneManager(this.loadingProgress);
        this.diContainer.register("SceneManager",{ object:this.sceneManager, scope:"Singleton" });


        this.toolsManager = this._initToolsManager();
        this.controlsManager = this._initControlManager();


        if (setup.sceneObjects && setup.sceneObjects.potreePointCloud) {
            this.composedScene.pointcloud = this.objectLoader.loadPointCloud(setup.sceneObjects.potreePointCloud, this.composedScene);
        }
    },
    update:function(){
        Potree.pointLoadLimit = this.settings.sceneProperties.pointLimit * 2 * 1000 * 1000;// To millions.
        this.sceneManager.update();
        //scene camera
        // Pass into SceneManager, the scene proeprties.. DUH!
        this.composedScene.camera.fov = this.settings.sceneProperties.fov;
        //controls.update
        this.controlsManager.update(this.clock.getDelta());
        this.toolsManager.update();


        this.objectLoader.update();
        this.sceneManager.postUpdate();

    }
});

LT.Initialise = function (setup){
    LT.Instances = {};
    if (!(setup instanceof LT.Defns.DefaultSetup)) throw "Setup needs to be an instance of LT.Defns.DefaultSetup";
    LT.ActiveSetup = setup;

    if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
        LT.ActiveSetup.sceneProperties.navigation = LT.ActiveSetup.sceneProperties.mobileNavigation || "Orbit";
    }

    if(LT.ActiveSetup.sceneProperties.useEDL && !Potree.Features.SHADER_EDL.isSupported()){
        LT.ActiveSetup.sceneProperties.useEDL = false;
    }

    if(LT.ActiveSetup.sceneProperties.quality === null){
        LT.ActiveSetup.sceneProperties.quality = "Squares";
    }

    var fov = LT.ActiveSetup.sceneProperties.fov;
    var pointSize = LT.ActiveSetup.sceneProperties.pointSize;
    //var pointCountTarget = LT.ActiveSetup.sceneProperties.pointLimit;
    var opacity = 1;
    var pointSizeType = LT.ActiveSetup.getPointSizeType();
    var pointColorType = LT.ActiveSetup.getMaterial();
    //var pointShape = Potree.PointShape.SQUARE;
    var clipMode = Potree.ClipMode.HIGHLIGHT_INSIDE;
    var quality = LT.ActiveSetup.getQuality();
    var isFlipYZ = false;
    //var useDEMCollisions = false;
    var minNodeSize = 100;
    //var directionalLight;

    var showStats = false;
    var showBoundingBox = false;
    var freeze = false;

    //var fpControls;
    //var orbitControls;
    //var earthControls;
    //var controls;

    var progressBar = new ProgressBar();

    var pointcloudPath = sceneProperties.path;

    var elRenderArea = document.getElementById(finalSetup.renderArea);

    var gui;
    var renderer;
    var camera;
    var scene;
    var scenePointCloud;
    var sceneBG, cameraBG;
    var pointcloud;
    var skybox;
    var stats;
    //var clock = new THREE.Clock();
    var showSkybox = false;
    var measuringTool;
    var volumeTool;
    var transformationTool;
    //var referenceFrame;

    function initGUI(){
        // dat.gui
        gui = new dat.GUI({
            //height : 5 * 32 - 1
        });

        params = {
            "points(m)": pointCountTarget,
            PointSize: pointSize,
            "FOV": sceneProperties.fov,
            "opacity": opacity,
            "SizeType" : sceneProperties.sizeType,
            "show octree" : false,
            "Materials" : sceneProperties.material,
            "Clip Mode": "Highlight Inside",
            "quality": sceneProperties.quality,
            "EDL": sceneProperties.useEDL,
            "skybox": false,
            "stats": showStats,
            "BoundingBox": showBoundingBox,
            "DEM Collisions": useDEMCollisions,
            "MinNodeSize": minNodeSize,
            "freeze": freeze
        };

        var pPoints = gui.add(params, 'points(m)', 0, 4);
        pPoints.onChange(function(value){
            pointCountTarget = value ;
        });

        var fAppearance = gui.addFolder('Appearance');

        var pPointSize = fAppearance.add(params, 'PointSize', 0, 3);
        pPointSize.onChange(function(value){
            pointSize = value;
        });

        var fFOV = fAppearance.add(params, 'FOV', 20, 100);
        fFOV.onChange(function(value){
            fov = value;
        });

        var pOpacity = fAppearance.add(params, 'opacity', 0, 1);
        pOpacity.onChange(function(value){
            opacity = value;
        });

        var pSizeType = fAppearance.add(params, 'SizeType', [ "Fixed", "Attenuated", "Adaptive"]);
        pSizeType.onChange(function(value){
            setPointSizeType(value);
        });

        var options = [];
        var attributes = pointcloud.pcoGeometry.pointAttributes
        if(attributes === "LAS" || attributes === "LAZ"){
            options = [
                "RGB", "Color", "Elevation", "Intensity", "Intensity Gradient",
                "Classification", "Return Number", "Source",
                "Tree Depth"];
        }else{
            for(var i = 0; i < attributes.attributes.length; i++){
                var attribute = attributes.attributes[i];

                if(attribute === Potree.PointAttribute.COLOR_PACKED){
                    options.push("RGB");
                }else if(attribute === Potree.PointAttribute.INTENSITY){
                    options.push("Intensity");
                    options.push("Intensity Gradient");
                }else if(attribute === Potree.PointAttribute.CLASSIFICATION){
                    options.push("Classification");
                }
            }
            if(attributes.hasNormals()){
                options.push("Phong");
                options.push("Normal");
            }

            options.push("Elevation");
            options.push("Color");
            options.push("Tree Depth");
        }

        // default material is not available. set material to Elevation
        if(options.indexOf(params.Materials) < 0){
            console.error("Default Material '" + params.Material + "' is not available. Using Elevation instead");
            setMaterial("Elevation");
            params.Materials = "Elevation";
        }


        pMaterial = fAppearance.add(params, 'Materials',options);
        pMaterial.onChange(function(value){
            setMaterial(value);
        });

        var qualityOptions = ["Squares", "Circles"];
        if(Potree.Features.SHADER_INTERPOLATION.isSupported()){
            qualityOptions.push("Interpolation");
        }
        if(Potree.Features.SHADER_SPLATS.isSupported()){
            qualityOptions.push("Splats");
        }
        var pQuality = fAppearance.add(params, 'quality', qualityOptions);
        pQuality.onChange(function(value){
            quality = value;
        });

        if(Potree.Features.SHADER_EDL.isSupported()){
            var pEDL = fAppearance.add(params, 'EDL');
            pEDL.onChange(function(value){
                sceneProperties.useEDL = value;
            });
        }

        var pSykbox = fAppearance.add(params, 'skybox');
        pSykbox.onChange(function(value){
            showSkybox = value;
        });

        var fSettings = gui.addFolder('Settings');

        var pClipMode = fSettings.add(params, 'Clip Mode', [ "No Clipping", "Clip Outside", "Highlight Inside"]);
        pClipMode.onChange(function(value){
            if(value === "No Clipping"){
                clipMode = Potree.ClipMode.DISABLED;
            }else if(value === "Clip Outside"){
                clipMode = Potree.ClipMode.CLIP_OUTSIDE;
            }else if(value === "Highlight Inside"){
                clipMode = Potree.ClipMode.HIGHLIGHT_INSIDE;
            }
        });

        var pDEMCollisions = fSettings.add(params, 'DEM Collisions');
        pDEMCollisions.onChange(function(value){
            //useDEMCollisions = value;
            // set DEM Collisions property on controls
        });

        var pMinNodeSize = fSettings.add(params, 'MinNodeSize', 0, 1500);
        pMinNodeSize.onChange(function(value){
            minNodeSize = value;
        });




        var fDebug = gui.addFolder('Debug');


        var pStats = fDebug.add(params, 'stats');
        pStats.onChange(function(value){
            showStats = value;
        });

        var pBoundingBox = fDebug.add(params, 'BoundingBox');
        pBoundingBox.onChange(function(value){
            showBoundingBox = value;
        });

        var pFreeze = fDebug.add(params, 'freeze');
        pFreeze.onChange(function(value){
            freeze = value;
        });

        // stats
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.margin = '5px';
        document.body.appendChild( stats.domElement );
    }

    function initThree(){
        //var width = elRenderArea.clientWidth;
        //var height = elRenderArea.clientHeight;

        // Stupid progress bar example, until merged with ember, then wont need this shite.
        LT.ActiveSetup.progress.element = progressBar.element;
        LT.ActiveSetup.progress.bar = progressBar.elProgress;


        //var composedScene = new LT.Defns.Scene.ComposedScene(width,height);
        //elRenderArea.appendChild(composedScene.renderer.domElement);


        LT.Instances.Engine = new LT.Defns.Engine.LTEngine();

        // Dont do this, inherit ya damn idjit.
        LT.Instances.Engine._initControlManager = function(){
            return new LT.Defns.Controls.LT_MainViewerControlsManager(
                this.composedScene.camera,
                this.composedScene.renderer,
                this.composedScene.pointcloud,
                this.settings.controlProperties.useDEMCollisions);
        }
        LT.Instances.Engine._initObjectLoader = function(){
            return new LT.Defns.Loaders.LT_MainObjectLoader();
        }
        LT.Instances.Engine._initToolsManager = function(){
            return new LT.Defns.Tools.LT_MainViewerToolManager(
                this.composedScene.scenePointCloud,
                this.composedScene.camera,
                this.composedScene.renderer);
        }
        LT.Instances.Engine._initControlManager = function(){
            return new LT.Defns.Controls.LT_MainViewerControlsManager(
                this.composedScene.camera,
                this.composedScene.renderer,
                this.composedScene.pointcloud,
                this.settings.controlProperties.useDEMCollisions);
        }
        LT.Instances.Engine._initSceneManager = function(){
            var sm = new LT.Defns.Scene.SceneManager(
                this.settings.getRenderArea(),
                this.composedScene,
                new LT.Defns.Scene.PotreeSceneProcessor(),
                this.toolsManager);

            sm.addProcessor("HQ", new LT.Defns.Scene.HighQualityProcessor());
            sm.addProcessor("EDL", new LT.Defns.Scene.EDLProcessor());

            return sm;
        }

        LT.Instances.Engine.initialise(LT.ActiveSetup)

        var sceneManager = LT.Instances.Engine.sceneManager;


        //var toolsManager = new LT.Defns.Tools.LT_MainViewerToolManager(composedScene.scenePointCloud, composedScene.camera, composedScene.renderer);
        //renderLocation, renderer, processor, camera
        /*
        var sceneManager = new LT.Defns.Scene.SceneManager(
            elRenderArea,
            composedScene,
            new LT.Defns.Scene.PotreeSceneProcessor(),
            toolsManager);

        sceneManager.addProcessor("HQ", new LT.Defns.Scene.HighQualityProcessor());
        sceneManager.addProcessor("EDL", new LT.Defns.Scene.EDLProcessor());
*/
        //camera, renderer, pointcloud, useDEMCollisions
        //var controlManager = new LT.Defns.Controls.LT_MainViewerControlsManager(composedScene.camera, composedScene.renderer, composedScene.pointcloud, useDEMCollisions);

        sceneManager.addToScene(Potree.utils.createGrid(5, 5, 2));

        var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        //directionalLight.position.set( 10, 10, 10 );
        //directionalLight.lookAt( new THREE.Vector3(0, 0, 0));

        directionalLight.position.copy(composedScene.camera.position);
        directionalLight.lookAt(new THREE.Vector3().addVectors(composedScene.camera.position, composedScene.camera.getWorldDirection()));
        scenePointCloud.add( directionalLight );

        composedScene.camera.add(directionalLight);
        sceneManager.addToScene(composedScene.camera);
        sceneManager.addLight(directionalLight)

        sceneManager.addLight(new THREE.AmbientLight( 0x555555 ))

    }


    function update(){
        LT.Instances.Engine.update();
        //Potree.pointLoadLimit = pointCountTarget * 2 * 1000 * 1000;

        //directionalLight.position.copy(camera.position);
        //directionalLight.lookAt(new THREE.Vector3().addVectors(camera.position, camera.getWorldDirection()));
/*
        if(pointcloud){

            var bbWorld = Potree.utils.computeTransformedBoundingBox(pointcloud.boundingBox, pointcloud.matrixWorld);

            if(!intensityMax){
                var root = pointcloud.pcoGeometry.root;
                if(root != null && root.loaded){
                    var attributes = pointcloud.pcoGeometry.root.geometry.attributes;
                    if(attributes.intensity){
                        var array = attributes.intensity.array;
                        var max = 0;
                        for(var i = 0; i < array.length; i++){
                            max = Math.max(array[i]);
                        }

                        if(max <= 1){
                            intensityMax = 1;
                        }else if(max <= 256){
                            intensityMax = 255;
                        }else{
                            intensityMax = max;
                        }
                    }
                }
            }

            if(heightMin === null){
                heightMin = bbWorld.min.y;
                heightMax = bbWorld.max.y;
            }

            pointcloud.material.clipMode = clipMode;
            pointcloud.material.heightMin = heightMin;
            pointcloud.material.heightMax = heightMax;
            pointcloud.material.intensityMin = 0;
            pointcloud.material.intensityMax = intensityMax;
            pointcloud.showBoundingBox = showBoundingBox;
            pointcloud.generateDEM = useDEMCollisions;
            pointcloud.minimumNodePixelSize = minNodeSize;

            if(!freeze){
                pointcloud.update(camera, renderer);
            }
        }*/

        if(stats && showStats){
            document.getElementById("lblNumVisibleNodes").style.display = "";
            document.getElementById("lblNumVisiblePoints").style.display = "";
            stats.domElement.style.display = "";

            stats.update();

            if(pointcloud){
                document.getElementById("lblNumVisibleNodes").innerHTML = "visible nodes: " + pointcloud.numVisibleNodes;
                document.getElementById("lblNumVisiblePoints").innerHTML = "visible points: " + Potree.utils.addCommas(pointcloud.numVisiblePoints);
            }
        }else if(stats){
            document.getElementById("lblNumVisibleNodes").style.display = "none";
            document.getElementById("lblNumVisiblePoints").style.display = "none";
            stats.domElement.style.display = "none";
        }

        //camera.fov = fov;

        //if(controls){
//            controls.update(clock.getDelta());
//        }

        // update progress bar
        /*
        if(pointcloud){
            var progress = pointcloud.progress;

            progressBar.progress = progress;

            var message;
            if(progress === 0 || pointcloud instanceof Potree.PointCloudArena4D){
                message = "loading";
            }else{
                message = "loading: " + parseInt(progress*100) + "%";
            }
            progressBar.message = message;

            if(progress === 1){
                progressBar.hide();
            }else if(progress < 1){
                progressBar.show();
            }
        }

*/
            //  In sceneManager.update() already.
        //volumeTool.update();
        //transformationTool.update();
        //profileTool.update();


        var clipBoxes = [];

        for(var i = 0; i < profileTool.profiles.length; i++){
            var profile = profileTool.profiles[i];

            for(var j = 0; j < profile.boxes.length; j++){
                var box = profile.boxes[j];
                box.updateMatrixWorld();
                var boxInverse = new THREE.Matrix4().getInverse(box.matrixWorld);
                clipBoxes.push(boxInverse);
            }
        }

        for(var i = 0; i < volumeTool.volumes.length; i++){
            var volume = volumeTool.volumes[i];

            if(volume.clip){
                volume.updateMatrixWorld();
                var boxInverse = new THREE.Matrix4().getInverse(volume.matrixWorld);

                clipBoxes.push(boxInverse);
            }
        }

        if(pointcloud){
            pointcloud.material.setClipBoxes(clipBoxes);
        }
    }

    function loop() {
        requestAnimationFrame(loop);

        update();

        if(sceneProperties.useEDL){
            if(!edlRenderer){
                edlRenderer = new EDLRenderer();
            }
            edlRenderer.render(renderer);
        }else if(quality === "Splats"){
            if(!highQualityRenderer){
                highQualityRenderer = new HighQualityRenderer();
            }
            highQualityRenderer.render(renderer);
        }else{
            potreeRenderer.render();
        }
    };

    initThree();
    loop();
}
LT.Initialise(new LT.Defns.DefaultSetup());